#pragma config(Sensor, in1,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, dgtl2,  ArmPos,         sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  RightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  LeftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           driveLT,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveRT,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           armLL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           armUL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           armLR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armUR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           pincherL,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           pincherR,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          preload,       tmotorVex269_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*               Description: Competition code for VEX EDR                   */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

int releaseArm = 0;//global variablr that releases loop that holds arm at set position
int atPos = 0;//global variable that shows if arm is in set position and holding

int leftEncoderDistance = 0;
int leftEncoderPower = 0;
int rightEncoderDistance = 0;
int rightEncoderPower = 0;

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}

task LCDDisplay()
{
	//http://www.robotc.net/blog/2012/05/18/advanced-applications-with-the-vex-lcd//

	SensorType[ dgtl8 ] = sensorNone;//Starting fresh
	SensorType[ dgtl8 ] = sensorQuadEncoder;//Redeclaring

	/*
	120 = 3360ctsleft
	120inches = 3325 right
	28 counts/inch
	*/

	/*
	SensorType[ dgtl10 ] = sensorNone;
	SensorType[ dgtl10 ] = sensorQuadEncoder;
	*/

	int PotentiometerValue;//Assigns Potentiometer Value to an integer
	int LTS = 0;//Declares a variable
	int RTS = 0;//Declares a variable
	int Encoder = 0;//Declares encoder

	int DREncoder = 0;//Declares right drive encoder
	int DLEncoder = 0;//Declares left drive encoder

	const short leftButton = 1;//Declares the left button at value 1
	const short centerButton = 2;//Declares the center button at value 2
	const short rightButton = 4;//Declares the right button at value 4

	int displayMode = 0;//default to potentiometer
	int MenuMode = 0;

	while (1==1)
	{

		/*------------------------------------------------------------------------*/
		/*                                                                        */
		/*                  Below is the code for the LCD menu                    */
		/*                                                                        */
		/*------------------------------------------------------------------------*/

		if (nLCDButtons != 0)
		{
			MenuMode = 1;
			while(nLCDButtons != centerButton && MenuMode > 0)
			{
				if (MenuMode == 1)
				{
					clearLCDLine(0);//Clear the first line
					clearLCDLine(1);//Clear the second line
					displayLCDPos(0, 0);//Start all the way to the left on the First line
					displayLCDCenteredString(0, "Potentiometer");
					displayLCDPos(1, 0);//Start all the way to the left on the second line
					displayNextLCDString("<     Enter    >");
				}

				if (MenuMode == 2)
				{
					clearLCDLine(0);//Clear the first line
					clearLCDLine(1);//Clear the second line
					displayLCDPos(0, 0);//Start all the way to the left on the First line
					displayLCDCenteredString(0, "Arm Encoder");
					displayLCDPos(1, 0);//Start all the way to the left on the second line
					displayNextLCDString("<     Enter    >");
				}

				if (MenuMode == 3)
				{
					clearLCDLine(0);//Clear the first line
					clearLCDLine(1);//Clear the second line
					displayLCDPos(0, 0);//Start all the way to the left on the First line
					displayLCDCenteredString(0, "Drive Encoders");
					displayLCDPos(1, 0);//Start all the way to the left on the second line
					displayNextLCDString("<     Enter    >");
				}

				if (MenuMode == 4)
				{
					clearLCDLine(0);//Clear the first line
					clearLCDLine(1);//Clear the second line
					displayLCDPos(0, 0);//Start all the way to the left on the First line
					displayLCDCenteredString(0, "Range Finder");
					displayLCDPos(1, 0);//Start all the way to the left on the second line
					displayNextLCDString("<     Enter    >");
				}
				waitForRelease();

				if (nLCDButtons == centerButton)
				{
					if (MenuMode == 1)
					{
						displayMode = 0;
					}
					if (MenuMode == 2)
					{
						displayMode = 1;
					}
					if (MenuMode == 3)
					{
						displayMode = 2;
					}
					if (MenuMode == 4)
					{
						displayMode = 3;
					}
					MenuMode =0;
				}

				if (nLCDButtons == leftButton)
				{
					MenuMode -= 1;
					if (MenuMode < 1)
					{
						MenuMode = 1;
					}
				}

				if (nLCDButtons == rightButton)
				{
					MenuMode += 1;

					if (MenuMode > 4)
					{
						MenuMode = 4;
					}//End MenuMode > 4
				}//End rightButton Check
			}//End MenuMode While
		}//End Menu Button check

		/*------------------------------------------------------------------------*/
		/*                                                                        */
		/*                          LCD Module Control                            */
		/*          This is used to program our preload LCD Display screen        */
		/*                                                                        */
		/*------------------------------------------------------------------------*/

		PotentiometerValue = SensorValue [potentiometer];//Read sensor value

		/*
		LTS = SensorValue [LTSonar];//Read Left Sonar Value
		RTS = SensorValue [RTSonar];//Read Right Sonar Value
		*/

		Encoder = SensorValue [ArmPos];//Read the encoder
		DREncoder = SensorValue [RightEncoder];//Read the right drive encoder
		DLEncoder = SensorValue [LeftEncoder];//Read the left drive encoder

		/*Convert integer value into text
		char buf[5];
		sprintf(buf, "%d", PotentiometerValue);
		*/

		/*------------------------------------------------------------------------*/
		/*                                                                        */
		/*            Below is the string for the potentiometer display           */
		/*                                                                        */
		/*------------------------------------------------------------------------*/


		if (displayMode == 0)//Potentiometer
		{
			string display = "";//Show text within "" on LCD module

			if (PotentiometerValue <= 682)//If the potentiometer value is <=1000...
			{
				display = "Left Auton";//Read Left Auton on display
			}
			if (PotentiometerValue >= 683 && PotentiometerValue <= 1364)//If the potentiometer value is >=2001 but <=3000...
			{
				display = "Right Auton";//Read Right Auton on display
			}
			if (PotentiometerValue >= 1365 && PotentiometerValue <= 2046)//If the potentiometer value is >=3000 but >=4095...
			{
				display = "Left Post Auton";//Read right Post Auton on display
			}
			if (PotentiometerValue >= 2047 && PotentiometerValue <= 2728)//If the potentiometer value is >=3000 but >=4095...
			{
				display = "Right Post Auton";//Read left Post Auton on display
			}
			if (PotentiometerValue >= 2729 && PotentiometerValue <= 3410)//If the potentiometer value is >=3000 but >=4095...
			{
				display = "20 PT Left";//Read Defence Auton on display
			}
			if (PotentiometerValue >= 3411 && PotentiometerValue <= 4095)//If the potentiometer value is >=3000 but >=4095...
			{
				display = "20 PT Right";//Read 20 pt left on display
			}

			clearLCDLine (0);//Clear the first line on the LCD screen
			clearLCDLine (1);//Clear the second line on the LCD screen
			displayLCDCenteredString(0, display);//Display string on LCD
			wait1Msec(1000);//Wait/Stall for 1 second

		}// End displayMode 0 Potentiometer

		if (displayMode == 1)//Arm Encoder
		{
			clearLCDLine(0);//Clear the first line
			clearLCDLine(1);//Clear the second line
			displayLCDPos(0, 0);//Set the LCD position
			displayNextLCDString("Encoder: ");//Display text on screen
			displayNextLCDNumber(Encoder);//Fill space with value of Left sensor value
			//displayNextLCDString(" ");

			wait1Msec(1000);//Update every second
		}

		if (displayMode == 2)//Drive Encoders
		{
			clearLCDLine(0);//Clear the first line
			clearLCDLine(1);//Clear the second line
			displayLCDPos(0, 0);//Set the LCD position
			displayNextLCDString("DR Enc: ");//Display text on screen
			displayNextLCDNumber(DREncoder);//Fill space with value of Left sensor value
			displayLCDPos(1, 0);//Set the LCD position
			displayNextLCDString("DL Enc: ");//Display text on screen
			displayNextLCDNumber(DLEncoder);//Fill space with value of Left sensor value
			//displayNextLCDString(" ");

			wait1Msec(500);//Update every second
		}

		/*------------------------------------------------------------------------*/
		/*                                                                        */
		/*                 Below is the string for the URM display                */
		/*                                                                        */
		/*------------------------------------------------------------------------*/

		if (displayMode == 3)
		{
			clearLCDLine(0);//Clear the first line
			clearLCDLine(1);//Clear the second line
			displayLCDPos(0, 0);//Start all the way to the left on the first line
			displayNextLCDString("LT: ");//Display text on screen
			displayNextLCDNumber(LTS);//Fill space with value of Left sensor value
			displayLCDPos(1, 0);//Start all the way to the left on the second line
			displayNextLCDString("RT: ");//Display text on screen
			displayNextLCDNumber(RTS);//Fill space with the value of Right sensor value
			wait1Msec(1000);//Update every second
		}

		/*------------------------------------------------------------------------*/
		/*                                                                        */
		/*             Below is the string for the Encoder display                */
		/*                                                                        */
		/*------------------------------------------------------------------------*/

	}//End of while loop
}//End of LCD control

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	bLCDBacklight = true;//Turn on the LCD Screen
	startTask(LCDDisplay);//start the LCD Display task


	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

//Note: partner controller is written the same as main controller except it ends with Xmtr2 as seen below
//Example Main- motor [name of motor] = vexRT [Ch3]
//Example Partner- motor [name of motor] = vexRT [Ch3Xmtr2]

/*------------------------------------------------------------------------*/
/*                                                                        */
/*                               Methods                                  */
/*            Below are the following methods for autonomous              */
/*                                                                        */
/*------------------------------------------------------------------------*/

void SetArmMotorPower (int armPower){//All four arm motors run
	motor [armLL] = armPower;//Turn on the lower left arm motor
	motor [armUL] = armPower;//Turn on the upper left arm motor
	motor [armLR] = armPower;//Turn on the lower right arm motor
	motor [armUR] = armPower;//Turn on the upper right arm motor
}

void openpinchers (int power){//Arm lifts up
	motor [armLL] = power;//Turn on the lower left arm motor
	motor [armUL] = power;//Turn on the upper left arm motor
	motor [armLR] = power;//Turn on the lower right arm motor
	motor [armUR] = power;//Turn on the upper right arm motor
	wait1Msec (200);//Wait for 1 second
	motor [armLL] = 0;//Turn off the lower left arm motor
	motor [armUL] = 0;//Turn off the upper left arm motor
	motor [armLR] = 0;//Turn off the lower right arm motor
	motor [armUR] = 0;//Turn off the upper right arm motor
	motor [pincherR] = power;//Turn on the right pincher
	motor [pincherL] = power;//Turn on the left pincher
	wait1Msec (500);//Wait for .575+ second
	motor [pincherR] = 0;//Turn off the right pincher
	motor [pincherL] = 0;//Turn off the left pincher
	motor [armLL] = -power;//Turn on the lower left arm motor
	motor [armUL] = -power;//Turn on the upper left arm motor
	motor [armLR] = -power;//Turn on the lower right arm motor
	motor [armUR] = -power;//Turn on the upper right arm motor
	wait1Msec (500);//Wait for 1 second
	motor [armLL] = 0;//Turn off the lower left arm motor
	motor [armUL] = 0;//Turn off the upper left arm motor
	motor [armLR] = 0;//Turn off the lower right arm motor
	motor [armUR] = 0;//Turn off the upper right arm motor
}

void driveforward (int power){//Robot moves forward for 5 seconds
	motor [driveLT] = power;//Motor left drive turns on
	motor [driveRT] = power;// Motor right drive turns on
	wait1Msec (2500);//Wait for 2.5 seconds
	motor [driveLT] = 0;//Motor left drive turns off
	motor [driveRT] = 0;//Motor right drive turns off
}

void driveforwardtwo (int power){//Robot moves forward for 2 seconds
	motor [driveLT] = power;//Motor left drive turns on
	motor [driveRT] = power;// Motor right drive turns on
	wait1Msec (2700);//Wait for 2.6 seconds
	motor [driveLT] = 0;//Motor left drive turns off
	motor [driveRT] = 0;//Motor right drive turns off
}

void driveforwardthree (int power){//Robot moves forward for 5 seconds
motor [driveLT] = power;//Motor left drive turns on
motor [driveRT] = power;// Motor right drive turns on
wait1Msec (3000);//Wait for 1 seconds
motor [driveLT] = 0;//Motor left drive turns off
motor [driveRT] = 0;//Motor right drive turns off
}

void drivebackward (int power){//Robot moves backward for 5 seconds
	motor [driveLT] = -power;//Motor left drive turns on
	motor [driveRT] = -power;// Motor right drive turns on
	wait1Msec (2500);//Wait for 2.50 seconds
	motor [driveLT] = 0;//Motor left drive turns off
	motor [driveRT] = 0;//Motor right drive turns off
}

void drivebackwardtwo (int power){//Robot moves backward for 5 seconds
	motor [driveLT] = -power;//Motor left drive turns on
	motor [driveRT] = -power;// Motor right drive turns on
	wait1Msec (2000);//Wait for one second
	motor [driveLT] = 0;//Motor left drive turns off
	motor [driveRT] = 0;//Motor right drive turns off
}

/*
void liftarm (int power) {//Robot's arm lifts up
motor [armLL] = power;//Turn on the lower left arm motor
motor [armUL] = power;//Turn on the upper left arm motor
motor [armLR] = power;//Turn on the lower right arm motor
motor [armUR] = power;//Turn on the upper right arm motor
wait1Msec (750);//Lift arm for .75 seconds
motor [armLL] = 25;//Turn on the lower left arm motor
motor [armUL] = 25;//Turn on the upper left arm motor
motor [armLR] = 25;//Turn on the lower right arm motor
motor [armUR] = 25;//Turn on the upper right arm motor
}
*/

/*
void lowerarmtwo (int power) {//Robot's arm lowers
motor [armLL] = -power;//Turn on the lower left arm motor
motor [armUL] = -power;//Turn on the upper left arm motor
motor [armLR] = -power;//Turn on the lower right arm motor
motor [armUR] = -power;//Turn on the upper right arm motor
wait1Msec (390);//Lowers arm for .78 seconds
motor [armLL] = 0;//Turn off the lower left arm motor
motor [armUL] = 0;//Turn off the upper left arm motor
motor [armLR] = 0;//Turn off the lower right arm motor
motor [armUR] = 0;//Turn off the upper right arm motor
}
*/

void preloader (int power) {//The robot places the preload on the robot
	motor [preload] = -20;//Turn on the preload motor
	wait1Msec (750);//Preloader goes down for 1/2 a second
	motor [preload] = 100;//Turn on the preload motor to 100/127
	wait1Msec (150);//Preloader goes up for .15 of a second
	motor [preload] = 0;//Turn off the preload motor
}

void preloadertwo (int power) {//The robot places the preload on the robot
	motor [preload] = -10;//Turn on the preload motor
	wait1Msec (1000);//Preloader goes down for 1 second
}

//End of methods for autonomous


/*------------------------------------------------------------------------*/
/*                                                                        */
/*                               Tasks                                    */
/*             Below are the following tasks for autonomous               */
/*                                                                        */
/*------------------------------------------------------------------------*/

/*
task sensorcontrol()
{
SensorValue[grnled] = false;
int lightOn = 0;//
while(1==1)
{
/*------------------------------------------------------------------------*/
/*                                                                        */
/*                           Sensor Control                               */
/*                This is used to program our sensor & Led                */
/*                                                                        */
/*------------------------------------------------------------------------*/
/*
if (vexRT [Btn8UXmtr2] == 1)//If button 8U is pressed on the partner controller
{
SensorValue[grnled] = true;//When the grnled is true
lightOn = 1;//Light equals one (turns on)
}//End if statement
else
{
if (lightOn == 1)//If the above statement is true
{
SensorValue[grnled] = false;//The grnled is false
lightOn = 0;//Light equals zero (turns off)
}
}//End else statement
}//This is the end of the while loop
}//This is the end of the sensor control

*/

task preloadactuator()
{
	while (1==1)

	/*------------------------------------------------------------------------*/
	/*                                                                        */
	/*                       Preload Actuator Control                         */
	/*             This is used to program our preload actuator               */
	/*                                                                        */
	/*------------------------------------------------------------------------*/
	{
		if (vexRT [Btn8LXmtr2] == 1)//When button 8L on the partner controller is pressed...
		{
			motor [preload] = -40;//Run the preloader at full power
		}
		else if (vexRT [Btn8LXmtr2] == 0)//When the button is not pressed...
		{
			motor [preload] = 0;//Stop running the preloader
		}

		if (vexRT [Btn8RXmtr2] == 1)//When button 8L on the partner controller is pressed...
		{
			motor [preload] = 100;//Run the preloader at full power
		}
		else if (vexRT [Btn8RXmtr2] == 0)//When the button is not pressed...
		{
			motor [preload] = 0;//Stop running the preloader
		}
	}//End of Preloader Control
}//End of while loop

task speakercontrol()
{
	while (1==1)

	/*------------------------------------------------------------------------*/
	/*                                                                        */
	/*                           Speaker Control                              */
	/*                  This is used to program our speaker                   */
	/*                                                                        */
	/*------------------------------------------------------------------------*/

	{
		if (vexRT [Btn8U] == 1)//When button 8U is pressed
		{
			playSoundFile ("hellocharlie.wav");//Play sound file hello my name is charlie 4.0
			wait1Msec (2600);// Wait 2.6 seconds
		}

		if (vexRT [Btn8R] == 1)//When button 8r is pressed
		{
			playSoundFile ("functions.wav");//Play sound file funtions
			wait1Msec (4500);// Wait 4.5 seconds
		}

		if (vexRT [Btn8D] == 1)//When button 8r is pressed
		{
			playSoundFile ("teammajortroub.wav");//Play sound file team major trouble
			wait1Msec (1700);// Wait 1.7 seconds
		}

		if (vexRT [Btn8L] == 1)//When button 8r is pressed
		{
			playSoundFile ("thankyou.wav");//Play sound file thankyou
			wait1Msec (1300);// Wait 1.3 seconds
		}

		if (vexRT [Btn7U] == 1)//When button 7U is pressed
		{
			playSoundFile ("majortroubleto.wav");//Play sound file merry christmas :)
			wait1Msec (3100);// Wait 3.1 seconds
		}

		wait1Msec (250);

	}//End of loop inside speaker control task
} //End speakercontrol task


/*------------------------------------------------------------------------*/
/*                                                                        */
/*                               Methods                                  */
/*             Below are the following methods for the Encoder            */
/*                                                                        */
/*------------------------------------------------------------------------*/

void GoToPositionAndHold(int positionToHold)//Assigns position of arm to encoder and holds
{
	int curPos = SensorValue[ArmPos];//Defines arm position is the same as current position
	int difBtwPos = 0;//Difference between positions is set to zero
	atPos = 0;//At position is set to zero (flag)
	releaseArm = 0;

	while (vexRT [Ch3Xmtr2] > -30 && vexRT [Ch3Xmtr2] < 30 && releaseArm == 0)//Moving controller will switch back to manual
	{
		curPos = SensorValue[ArmPos];//Arm position is the same as current position

		//Above needed Position
		if (curPos > positionToHold)//If the arm position is greater than the position we want to get to...
		{
			difBtwPos = (curPos - positionToHold);//Difference between the arm position and where we want to get to
			if (difBtwPos > 50)//If the difference is greater than 50...
			{
				SetArmMotorPower (-50);//All arm motors run at -50 (go down)
			}
			else if (difBtwPos > 20 && difBtwPos <= 50)//Else if the difference is greater than 30...
			{
				SetArmMotorPower (-40);//All arm motors run at -40 (go down)
			}
			else if (difBtwPos > 10 && difBtwPos <= 20)//Else if the difference is greater than 30...
			{
				SetArmMotorPower (-30);//All arm motors run at -40 (go down)
			}


			else if (difBtwPos < 2 && difBtwPos > -2)//Else if the difference is between 3 and -3...
			{
				SetArmMotorPower (0);//Arm motors turn off
				atPos = 1;//Signal that arm is in position
			}
			else
			{
				SetArmMotorPower (-10);//Arm motors turn off
			}



		}//End Above Conditions

		//Below needed Position
		if (curPos < positionToHold)//If the arm position is less than where we want to go...
		{
			difBtwPos = (positionToHold - curPos);//Difference is the same as where we want to go - arm position
			if (difBtwPos > 50)//If the difference is greater than 50...
			{
				SetArmMotorPower (50);//Arm motors run at 50 (go up)
			}
			else if (difBtwPos > 20 && difBtwPos <= 50)//Else if the difference is greater than 30...
			{
				SetArmMotorPower (40);//Arm motors run at 40 (go up)
			}
			else if (difBtwPos > 10 && difBtwPos <= 20)//Else if the difference is greater than 30...
			{
				//SetArmMotorPower (0);
				SetArmMotorPower (30);//Arm motors run at 40 (go up)
			}

			else if (difBtwPos < 2 && difBtwPos > -2)//Else if the difference is between 3 and -3...
			{
				SetArmMotorPower (0);//Arm motors turn off
				atPos = 1;//Signal that arm is in position
			}
			else //Else if the difference is greater than 30...
			{
				//SetArmMotorPower (0);
				SetArmMotorPower (20);//Arm motors run at 40 (go up)
			}


		}//End Below Conditions

		if ((curPos - positionToHold) < 2 && (curPos - positionToHold) > - 2)//If the desired position is between -2 and 2...
		{
			atPos = 1;//Signal that arm is in position
			SetArmMotorPower (0);
		}

		if (vexRT[Btn8UXmtr2] == 1 && atPos == 1)//When button 8U is pressed and is at the desired position
		{
			//Preset Positions 40, 50, 62, 75, 90, 105
			if (positionToHold < 40)//If the desired position is less than 40
			{
				positionToHold = 40;//When button is pressed move up to 40
			}
			else if (positionToHold == 40)//Arm position is at 40
			{
				positionToHold = 43;//When button is pressed move up to 50
			}
			else if (positionToHold == 43)//Arm position is at 40
			{
				positionToHold = 50;//When button is pressed move up to 50
			}
			else if (positionToHold == 50)//Arm position is at 50
			{
				positionToHold = 62;//When button is pressed move up to 62
			}
			else if (positionToHold == 62)//Arm position is at 62
			{
				positionToHold = 75;//When button is pressed move up to 75
			}
			else if (positionToHold == 75)//Arm position is at 75
			{
				positionToHold = 90;//When button is pressed move up to 90
			}
			atPos = 0;//Signal that arm is in position
		}

		if (vexRT[Btn8DXmtr2] == 1 && atPos == 1)//If button 8D is pressed, only moves onto next position after previous position
		{
			//Preset Positions 40, 50, 62, 75, 90, 105

			if (positionToHold > 90)//If the desired position is greater than 90
			{
				positionToHold = 90;//Arm position equals 90
			}
			else if (positionToHold == 90)//Arm position is at 90
			{
				positionToHold = 75;//When button is pressed move down to 75
			}
			else if (positionToHold == 75)//Arm position is equal to 75
			{
				positionToHold = 62;//When button is pressed move down to 62
			}
			else if (positionToHold == 62)//Arm position equals 62
			{
				positionToHold = 50;//When button is pressed move down to 50
			}
			else if (positionToHold == 50)//Arm position equals 50
			{
				positionToHold = 43;//When button is pressed move down to 40
			}
			else if (positionToHold == 43)//Arm position equals 50
			{
				positionToHold = 40;//When button is pressed move down to 40
			}
			atPos = 0;//Signal that arm is in position
		}

		if (vexRT[Btn7LXmtr2] == 1 && atPos == 1)
		{

			positionToHold = 43;
			atPos = 0;
		}


	}//End While

}// End GoToPositionAndHold

task armcontrol()
{
	int armPower = vexRT [Ch3Xmtr2];//Defines arm power

	int EncoderPos = 0;//Defines encoder position is equal to zero

	while (1==1)

	/*------------------------------------------------------------------------*/
	/*                                                                        */
	/*                           Arm Control                                  */
	/*              This is used to move our arm up and down                  */
	/*                                                                        */
	/*------------------------------------------------------------------------*/
	{
		armPower = vexRT [Ch3Xmtr2];//The speed is an interger controled by how much the joystick (Channal) is pressed
		EncoderPos = SensorValue [ArmPos];//The encoder is the same as ArmPos

		if (EncoderPos > 95 && armPower > 20)//When the encoder is close to max value and armPower is above 20...
		{
			armPower = 20;//Arm speed isn't be faster than 20
		}
		if (EncoderPos < 5 && armPower < -20)
		{
			armPower = -20;//Arm speed isn't be faster then -20
		}

		SetArmMotorPower (armPower);//Run all four motors

		if (vexRT[Btn8UXmtr2] == 1)//When button 8U is pressed...
		{
			if (EncoderPos < 40)
			{
				GoToPositionAndHold(40);
			}
			else if (EncoderPos >= 40 && EncoderPos < 43)
			{
				GoToPositionAndHold(43);
			}
			else if (EncoderPos >= 43 && EncoderPos < 50)
			{
				GoToPositionAndHold(50);
			}
			else if (EncoderPos >= 50 && EncoderPos < 62)
			{
				GoToPositionAndHold(62);
			}
			else if (EncoderPos >= 62 && EncoderPos < 75)
			{
				GoToPositionAndHold(75);
			}
			else if (EncoderPos >= 75 && EncoderPos < 90)
			{
				GoToPositionAndHold(90);
			}

		}//End Up Button

		//Preset Positions 40, 50, 62, 75, 90, 105
		if (vexRT[Btn8DXmtr2] == 1)//When button 8D is pressed...
		{
			if (EncoderPos > 90)
			{
				GoToPositionAndHold(90);
			}
			else if (EncoderPos > 75 && EncoderPos <= 90)
			{
				GoToPositionAndHold(75);
			}
			else if (EncoderPos > 62 && EncoderPos <= 75)
			{
				GoToPositionAndHold(62);
			}
			else if (EncoderPos > 50 && EncoderPos <= 62)
			{
				GoToPositionAndHold(50);
			}
			else if (EncoderPos > 43 && EncoderPos <= 50)
			{
				GoToPositionAndHold(43);
			}
			else if (EncoderPos > 40 && EncoderPos <= 43)
			{
				GoToPositionAndHold(40);
			}
		}//End Down Button

		if (vexRT[Btn7LXmtr2] == 1)//When button 7L is pressed...
		{
			GoToPositionAndHold(43);
		}

	}//End of while loop
}//End of Arm Control

task pinchercontrol ()
{
	int HoldPincher = 0;
	while (1==1)
		/*------------------------------------------------------------------------*/
	/*                                                                        */
	/*                            Pincher Control                             */
	/*                  This is used to control our pinchers                  */
	/*                                                                        */
	/*------------------------------------------------------------------------*/

	if (vexRT [Btn5UXmtr2] == 1)//When button 5U on the partner controller is pressed
	{
		HoldPincher = 1;
		motor [pincherL] = 127;//The left pincher moves in
		motor [pincherR] = 127;//The right motor moves in
	}
	else if (vexRT [Btn5DXmtr2] == 1)//When button 5D on the partner controller is pressed
	{
		HoldPincher = 0;
		motor [pincherL] = -50;//The left pincher moves out
		motor [pincherR] = -50;//The right motor moves out
	}
	else
	{
		if (HoldPincher == 1)
		{
			motor [pincherL] = 20;//The right motor continues to add extra power																																																																															;//The left motor stops
			motor [pincherR] = 20;//The right motor continues to add extra power
		}
		else
		{
			(HoldPincher == 0);//If the pincher is moving out then don't add extra power
			motor [pincherL] = 0;//The left motor stops
			motor [pincherR] = 0;//The right motor stops
		}
	}
} //End of Pincher Control

/*
task clawcontrol()
{
while (1==1)

/*-----------------------------------------------------------------------*/
/*                                                                       */
/*                      Claw Up and Down Control                         */
/*             This contains our up and down claw control                */
/*                                                                       */
/*-----------------------------------------------------------------------*/

/*
{
if (vexRT [Btn8UXmtr2] == 1)//When button 6U on the partner control is pressed
{
motor [clawUD] = 127;//Motor claw up and down opens
}
else if (vexRT [Btn8DXmtr2] == 1)//When button 6D on the partner control is pressed
{
motor [clawUD] = -127;//Motor claw up and down closes
}
else
{
motor [clawUD] = 0;//Motor claw up and down is turned off
}
}//End of while loop
}//End of Claw Control

/*
task clawcontroltwo()
{
while (1==1)

/*-----------------------------------------------------------------------*/
/*                                                                       */
/*                    Claw Open and Close Control                        */
/*             This contains our up and down claw control                */
/*                                                                       */
/*-----------------------------------------------------------------------*/
/*
{
if (vexRT [Btn6UXmtr2] == 1)//When button 6U on the partner control is pressed
{
motor [clawOC] = 127;//Motor claw Open and Close opens
}
else if (vexRT [Btn6DXmtr2] == 1)//When button 6D on the partner control is pressed
{
motor [clawOC] = -127;//Motor claw Opens and Close closes
}
else
{
motor [clawOC] = 0;//Motor claw Open and Close is turned off
}
}//End of while loop
}//End of Claw Control Two
*/

/*-----------------------------------------------------------------------*/
/*                                                                       */
/*             Methods and Tasks for our autonomous code                 */
/*                                                                       */
/*-----------------------------------------------------------------------*/

task liftarmtwo ()//Lift arm to ecoder position 63
{
	GoToPositionAndHold (60);//Lift arm to unit 60
}

task liftarmthree ()//Lift arm to ecoder position 63
{
	GoToPositionAndHold (30);//Lift arm to unit 30
}

void driveforwardtopost (int power){//Robot moves forward for 1.15 seconds
	motor [driveLT] = power;//Motor left drive turns on
	motor [driveRT] = power;// Motor right drive turns on
	wait1Msec (1150);//Wait for 1.15 of a second
	motor [driveLT] = 0;//Motor left drive turns off
	motor [driveRT] = 0;//Motor right drive turns off
}

void drivebackwardandturn (int power){//Robot moves backward for 5 seconds
	motor [driveRT] = -power;// Motor right drive turns on
	wait1Msec (1800);//Wait for 1.9 seconds
	motor [driveRT] = 0;//Motor right drive turns off
}

void drivebackwardandturntwo (int power){//Robot moves backward for 1.75 seconds
	motor [driveLT] = -power;// Motor right drive turns on
	wait1Msec (1900);//Wait for 1.9 seconds
	motor [driveLT] = 0;//Motor left drive turns off
}

void drivebackwardfour (int power){//Robot moves backward
	motor [driveLT] = -power;// Motor left drives backward
	motor [driveRT] = -power;// Motor right drives backward
}

/*
void turnleft (int power){//Robot moves forward for 5 seconds
motor [driveLT] = 127;//Motor left drive turns on
motor [driveRT] = 10;// Motor right drive turns on
wait1Msec (500);//Wait for 1.5 seconds
motor [driveLT] = 0;//Motor left drive turns off
motor [driveRT] = 0;//Motor right drive turns off
}
*/

void lowerarm (int power) {//Robot's arm lowers
	releaseArm = 1;//Release the arm from the encoder loop
	motor [armLL] = -power;//Turn on the lower left arm motor
	motor [armUL] = -power;//Turn on the upper left arm motor
	motor [armLR] = -power;//Turn on the lower right arm motor
	motor [armUR] = -power;//Turn on the upper right arm motor
	wait1Msec (780);//Lowers arm for .78 seconds
	motor [armLL] = 0;//Turn off the lower left arm motor
	motor [armUL] = 0;//Turn off the upper left arm motor
	motor [armLR] = 0;//Turn off the lower right arm motor
	motor [armUR] = 0;//Turn off the upper right arm motor
}

/*-----------------------------------------------------------------------*/
/*                                                                       */
/*                          Drive Encoders                               */
/*                                                                       */
/*-----------------------------------------------------------------------*/


int inchesToCounts(int numInches)
{
	return (numInches * 28);//coverts inches to encoder counts
}

void driveforXinchesRight (int driveinches, int drivepower)
{

	int driveCounts = inchesToCounts(driveinches);//Call formula for converting inches to counts
	int CurEncoder = SensorValue [RightEncoder];
	int MaxDrive = 0;

	if (drivepower > 0)
	{
		MaxDrive = CurEncoder + driveCounts;

		while (CurEncoder < MaxDrive)
		{
			motor [driveRT] = drivepower;

			CurEncoder = SensorValue [RightEncoder];
		}
	}

	if (drivepower < 0)
	{
		MaxDrive = CurEncoder - driveCounts;

		while (CurEncoder > MaxDrive)
		{
			motor [driveRT] = drivepower;

			CurEncoder = SensorValue [RightEncoder];
		}
	}

	rightEncoderDistance = 0;
	rightEncoderPower = 0;

}//Drive For X Inches Right

void driveforXinchesLeft (int driveinches, int drivepower)
{

	int driveCounts = inchesToCounts(driveinches);//Call formula for converting inches to counts
	int CurEncoder = SensorValue [LeftEncoder];
	int MaxDrive = 0;

	if (drivepower > 0)
	{
		MaxDrive = CurEncoder + driveCounts;

		while (CurEncoder < MaxDrive)
		{
			motor [driveLT] = drivepower;

			CurEncoder = SensorValue [LeftEncoder];
		}
	}

	if (drivepower < 0)
	{
		MaxDrive = CurEncoder - driveCounts;

		while (CurEncoder > MaxDrive)
		{
			motor [driveLT] = drivepower;

			CurEncoder = SensorValue [LeftEncoder];
		}
	}

	leftEncoderDistance = 0;
	leftEncoderPower = 0;
}//Drive For X Inches Left

/*
void driveforXinchesBoth (int driveinches, int drivepower)
{

int driveCounts = inchesToCounts(driveinches);//Call formula for converting inches to counts

int CurEncoder = SensorValue [LeftEncoder];
int MaxDrive = CurEncoder + driveCounts;

while (CurEncoder < MaxDrive)
{
motor [driveLT] = drivepower;
motor [driveRT] = drivepower;

CurEncoder = SensorValue [LeftEncoder];
}
}//Drive For X Inches Left

task driveLeftTask()
{
	driveforXinchesLeft(leftEncoderDistance, leftEncoderPower);
	leftEncoderDistance = 0;
	leftEncoderPower = 0;
}

task driveRightTask()
{
	driveforXinchesRight(rightEncoderDistance, rightEncoderPower);
	rightEncoderDistance = 0;
	rightEncoderPower = 0;
}

void driveForX(int leftDistanceIn, int leftPower, int rightDistanceIn, int rightPower)
{
leftEncoderDistance = leftDistanceIn;
leftEncoderPower = leftPower;
rightEncoderDistance = rightDistanceIn;
rightEncoderPower = rightPower;

startTask(driveLeftTask);
startTask(driveRightTask);
int maxrun = 0;
while (leftEncoderDistance != 0 && rightEncoderDistance != 0)
{
maxrun = maxrun;
}
}
*/

/*-----------------------------------------------------------------------*/
/*                                                                       */
/*                         Autonomous Method                             */
/*                  This contains our autonomous code                    */
/*                                                                       */
/*-----------------------------------------------------------------------*/

void cAuton (){//Autonomous for the left starting side
	openpinchers (127);//The pinchers open at the start of autonomous period
	driveforward (127);//The robot moves forward for 2.25 seconds
	motor [pincherL] = 127;//Motor pincher left closes
	motor [pincherR] = 127;//Motor pincher right closes
	wait1Msec (300);//Wait for .3 of a second
	preloader (127);//Preload cone is lowered onto mobile goal
	motor [pincherL] = 10;//Motor pincher left closes
	motor [pincherR] = 10;//Motor pincher right closes
	wait1Msec (500);//Wait for 1/2 a second
	startTask (liftarmthree);//Arm raises up to position 30
	drivebackward (127);//Robot moves backward for 1 second
	motor [driveLT] = 127;//Left side moves forward
	motor [driveRT] = -127;//Right side moves backward
	wait1Msec (1700);//Wait for 1.7 seconds
	driveforwardtwo (127);//Drive forward for 2 seconds
	lowerarm (127);//Lower arm for .78 seconds
	motor [pincherL] = -127;// Motor pincher left opens
	motor [pincherR] = -127;//Motor pincher right opens
	wait1Msec (600);//wait for .6 of a second
	motor [pincherL] = 0;//Motor pincher left stops
	motor [pincherR] = 0;//Motor pincher right stops
	drivebackwardtwo (127);//Robot moves backward for 1 second

	/*
	Possible Auton with Encoders

	equation for encoders:
	120 inches = 3360 counts or 28 counts per inch

	SensorValue [LeftEncoder] = 0;
	SensorValue [RightEncoder] = 0;
	openpinchers (127);//The pinchers open at the start of autonomous period
	driveForX(48, 127, 48, 127);//Left Distance Power and Right Distance Power
	motor [driveRT] = 0;//Stop Motors
	motor [driveLT] = 0;//Stop Motors
	SensorValue [LeftEncoder] = 0;
	SensorValue [RightEncoder] = 0;

	motor [pincherL] = 127;//Motor pincher left closes
	motor [pincherR] = 127;//Motor pincher right closes
	wait1Msec (300);//Wait for .3 of a second
	preloader (127);//Preload cone is lowered onto mobile goal
	startTask(liftarmtwo);//Lift arm to position 53
	driveForX(48, -127, 48, -127);//Left Distance Power and Right Distance Power
	motor [driveRT] = 0;//Stop the right motor
	motor [driveLT] = 0;//Stop the left motor
	SensorValue [LeftEncoder] = 0;
	SensorValue [RightEncoder] = 0;
	*/
}

void cAutonTwo (){//Autonomous for the right starting side
	openpinchers (127);//The pinchers open at the start of autonomous period
	driveforward (127);//The robot moves forward for 2.25 seconds
	motor [pincherL] = 127;//Motor pincher left closes
	motor [pincherR] = 127;//Motor pincher right closes
	wait1Msec (300);//Wait for .3 of a second
	preloader (127);//Preload cone is lowered onto mobile goal
	motor [pincherL] = 10;//Motor pincher left closes
	motor [pincherR] = 10;//Motor pincher right closes
	wait1Msec (500);//Wait for 1/2 a second
	startTask (liftarmthree);//Arm raises up to position 30
	drivebackward (127);//Robot moves backward for 1 second
	motor [driveLT] = -127;//Left side moves forward
	motor [driveRT] = 127;//Right side moves backward
	wait1Msec (1700);//Wait for 1.7 seconds
	driveforwardtwo (127);//Drive forward for 2 seconds
	lowerarm (127);//Lower arm for .78 seconds
	motor [pincherL] = -127;// Motor pincher left opens
	motor [pincherR] = -127;//Motor pincher right opens
	wait1Msec (600);//wait for .6 of a second
	motor [pincherL] = 0;//Motor pincher left stops
	motor [pincherR] = 0;//Motor pincher right stops
	drivebackwardtwo (127);//Robot moves backward for 1 second
}

void cAutonThree (){//Left Post Auton
	startTask (liftarmtwo);//Lift arm to unit 63 on encoder
	driveforwardtopost (100);//Drive forward to post
	preloadertwo (127);//Drop preload
	drivebackwardandturn (127);//Right motor runs backward
	drivebackwardfour (127);//Drive backward for 8 seconds
}

void cAutonFour (){//Right Post Auton
	startTask (liftarmtwo);//Lift arm to unit 63 on encoder
	driveforwardtopost (60);//Drive forward to post
	preloadertwo (127);//Drop preload
	drivebackwardandturntwo (127);//Left motor runs backward
	drivebackwardfour (127);//Drive backward for 8 seconds
}

void cAutonFive (){////Twenty Point Autonomous Left
	openpinchers (127);//The pinchers open at the start of autonomous period
	driveforward (127);//The robot moves forward for 2.25 seconds
	motor [pincherL] = 127;//Motor pincher left closes
	motor [pincherR] = 127;//Motor pincher right closes
	wait1Msec (300);//Wait for .3 of a second
	preloader (127);//Preload cone is lowered onto mobile goal
	motor [pincherL] = 10;//Motor pincher left closes
	motor [pincherR] = 10;//Motor pincher right closes
	wait1Msec (500);//Wait for 1/2 a second
	startTask (liftarmthree);//Arm raises up to position 30
	drivebackward (127);//Robot moves backward for 1 second
	motor [driveLT] = 127;//Left side moves forward
	motor [driveRT] = -127;//Right side moves backward
	wait1Msec (1500);//Wait for 1.5 seconds
	driveforwardtwo (127);//Drive forward for 2 seconds
	lowerarm (127);//Lower arm for .78 seconds
	motor [pincherL] = -127;// Motor pincher left opens
	motor [pincherR] = -127;//Motor pincher right opens
	wait1Msec (600);//wait for .6 of a second
	motor [pincherL] = 0;//Motor pincher left stops
	motor [pincherR] = 0;//Motor pincher right stops
	drivebackwardtwo (127);//Robot moves backward for 1 second
}

void cAutonSix (){//Twenty Point Autonomous Right
	openpinchers (127);//The pinchers open at the start of autonomous period
	driveforward (127);//The robot moves forward for 2.25 seconds
	motor [pincherL] = 127;//Motor pincher left closes
	motor [pincherR] = 127;//Motor pincher right closes
	wait1Msec (300);//Wait for .3 of a second
	preloader (127);//Preload cone is lowered onto mobile goal
	motor [pincherL] = 10;//Motor pincher left closes
	motor [pincherR] = 10;//Motor pincher right closes
	wait1Msec (500);//Wait for 1/2 a second
	startTask (liftarmthree);//Arm raises up to position 30
	drivebackward (127);//Robot moves backward for 1 second
	motor [driveLT] = -127;//Left side moves forward
	motor [driveRT] = 127;//Right side moves backward
	wait1Msec (1400);//Wait for 1.5 seconds
	driveforwardthree (127);//Drive forward for 3 seconds
	lowerarm (127);//Lower arm for .78 seconds
	motor [pincherL] = -127;// Motor pincher left opens
	motor [pincherR] = -127;//Motor pincher right opens
	wait1Msec (600);//wait for .6 of a second
	motor [pincherL] = 0;//Motor pincher left stops
	motor [pincherR] = 0;//Motor pincher right stops
	drivebackwardtwo (127);//Robot moves backward for 1 second
}

task autonomous()//This is the begining of the Autonomous Code
//Autonomous Methods and Task are here inside the loop
{

	SensorType[ dgtl8 ] = sensorNone;//Starting fresh
	SensorType[ dgtl8 ] = sensorQuadEncoder;//Redeclaring

	if (SensorValue [potentiometer] <= 682)//Potentiometer is set btw. 0-1,000
	{
		cAuton();//Run through cAuton once (Left starting side)
	}//End of cAuton

	if (SensorValue [potentiometer] >= 682 && SensorValue [potentiometer] <= 1364)//Potentiometer is set btw. 1,001-2,000
	{
		cAutonTwo();//Run through cAutonTwo once (Right starting side)
	}

	if (SensorValue [potentiometer] >= 1365 && SensorValue [potentiometer] <= 2046)//Potentiometer is set btw. 2,001-3,000
	{
		cAutonThree();//Run through cAutonThree once (Right Post Auton)
	}

	if (SensorValue [potentiometer] >= 2047 && SensorValue [potentiometer] <= 2728)//Potentiometer is set btw. 3,001-maxd
	{
		cAutonFour();//Run through cAutonFour once (Left Post Auton)
	}//End of cAutonTwo

	if (SensorValue [potentiometer] >= 2729 && SensorValue [potentiometer] <= 3410)//Potentiometer is set btw. 3,001-maxd
	{
		cAutonFive();//Run through cAutonFour once (Defense Auton)
	}//End of cAutonTwo

	if (SensorValue [potentiometer] >= 3411 && SensorValue [potentiometer] <= 4095)//Potentiometer is set btw. 3,001-maxd
	{
		cAutonSix();//Run through cAutonFour once (Defense Auton)
	}//End of cAutonTwo

	/*
	if (SensorValue [jumperTwo] == 1)//Jumper Clip is in. . .
	{
	cAuton();//Run through cAuton once (Right starting side)
	}//End of cAuton

	else //Jumper Clip is out. . .
	{
	(SensorValue [jumperTwo] == 0);//Jumper Clip is out. . .
	cAutonTwo();//Run through cAutonTwo once (Left starting side)
	}//End of cAutonTwo
	*/

}//End of Autonomous

task usercontrol()
{
	startTask(armcontrol);//Start the arm control
	startTask(speakercontrol);//Start the speaker control
	startTask(LCDDisplay);//LCD display to show Potentiometer
	startTask(pinchercontrol);//Start the pincher control
	startTask(preloadactuator);//Start the preloadactuator

	/*
	startTask(clawcontrol);//Start the claw control
	startTask(clawcontroltwo);//Start the claw control two
	startTask(sensorcontrol);//Start the sensor control
	*/

	//User control here inside the loop

	while (1==1)

	/*------------------------------------------------------------------------*/
	/*                                                                        */
	/*                         Chassis Control                                */
	/*                  This is used to control our chassis                   */
	/*                                                                        */
	/*------------------------------------------------------------------------*/
	{
		motor [driveLT] = vexRT [Ch3]; // motor drive left is controlled by channel 3
		motor [driveRT] = vexRT [Ch2]; // motor drive right is controlled by channel 2
	} //End of chassis control
} //End of user control
